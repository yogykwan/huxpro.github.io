---
layout:     post
title:      "C++ Primer：类设计者的工具"
subtitle:   ""
date:       2017-03-14
author:     "Jennica"
header-img: "img/post-bg-cpp.jpg"
catalog: true
tags:
    - 技术
    - 读书
    - C++
---


> 道可道。

# 前言

把[《C++ Primer》](https://book.douban.com/subject/25708312/)读薄系列笔记，第III部分：类设计者的工具。

## 目录

[第I部分：C++基础](http://jennica.space/2017/01/13/cpp-primer-basic/)

1. 开始学习C++
2. 变量和基本类型
3. 字符串、向量和数组
4. 表达式
5. 语句
6. 函数
7. 类

[第II部分：C++标准库](http://jennica.space/2017/01/23/cpp-primer-stl/)

8. IO库
9. 顺序容器
10. 范型算法
11. 关联容器
12. 动态内存

[第III部分：类设计者的工具](http://jennica.space/2017/03/14/cpp-primer-ood/)

13. 拷贝控制
14. 重载运算与类型转换
15. 面向对象程序设计
16. 模版与泛型编程

## 题解
修订版**课后题解**见GitHub仓库：[cpp-primer-workbook](https://github.com/yogykwan/CppPrimer)。

# 拷贝控制

1. 拷贝控制成员函数：拷贝构造、拷贝赋值、移动构造、移动赋值、析构；不显式定义则编译器会生成合成版本
2. 逐成员拷贝／移动：合成的拷贝和移动构造函数及拷贝与移动赋值运算符的工作方式，依次处理非stastic数据成员
3. 拷贝构造函数：第一个参数必须是引用，常是const；不应设为explicit，因为某些情况下需隐式调用
4. 拷贝初始化：直接初始化要求编译器使用普通的函数匹配，拷贝初始化则是将右侧运算对象拷贝到正在创建的对象中，并可能发生类型转换；拷贝初始化发生在用=定义变量、实参传递给非引用形参、返回类型为非引用、花括号列表初始化数组中的元素或聚合类中的元素、初始化标准库容器或调用其insert或push成员
5. 绕过拷贝控制构造：编译器可以（非必需）跳过拷贝／移动构造函数，直接创建对象
6. 重载运算符：若运算符是成员函数，其左侧运算对象绑定到隐式this参数；对二元运算符，右侧运算对象作为显式参数传递
7. 赋值运算符：接受同类参数，返回指向左侧运算对象的引用
8. 析构函数：释放对象使用资源，并销毁非stastic数据成员；不接受参数，不能重载；先执行函数体，再按初始化的逆序隐式销毁成员；内置指针类型不会delete对象，智能指针是类类型所有可以释放；引用和值指针离开作用域不析构绑定对象
9. 三／五法则：5个拷贝控制成员应看作整体，定义了一个则应定义所有
10. 使用=default：显式要求编译器生成合成版本的默认构造函数或拷贝控制成员；类内声明=default为内联
11. 阻止拷贝：定义删除的拷贝控制函数；新标准发布前，通常将拷贝控制成员声明为private，并且不定义它们
12. 删除的函数：使用=delete在函数第一次出现时声明，之后不能以任何方式调用这些函数；析构函数不能是删除，否则不能定义该类型对象，只能new动态分配并无法释放；一个类有数据成员不能默认构造、拷贝、复制、摧毁则会被定义为删除的
13. 拷贝语义：类的行为像值，有自己的状态；类的行为像指针，共享状态；IO和unique_ptr不允许拷贝或赋值，值和指针都不像
14. 类值拷贝赋值：自赋值也是安全的，发生异常后左侧对象状态仍有意义；先拷贝构造右侧对象到临时变量，再销毁左侧成员并赋予新值
15. 引用计数：用于类指针拷贝控制成员中共享状态，构造、创建副本、赋值左侧递增，销毁、赋值右侧递减
16. 拷贝并交换：在赋值运算符中，参数不是引用，此时结合拷贝和交换的赋值运算符是安全的
17. 自定义拷贝控制成员：除了资源管理的原因，一些类还需要拷贝控制成员的帮助来进行簿记工作或其他操作，它们所具有的公共工作应放在private的工具函数中完成
18. 动态内存管理类：alloc_n_copy (allocate, uninitialized_copy), free(destroy, deallocate), push_back (chk_n_alloc, construct), chk_n_alloc (capacity, reallocate), reallocate (construct(std::move), free)
19. 右值引用：用&&获得，表示即将销毁的对象；返回非引用类型的函数、算数、关系、位以及后置递增递减运算符，用const左值引用或右值引用绑定；返回左值引用的函数、赋值、下标、解引用、和前置递增递减运算符，用非const左值绑定；绑定右值引用的变量仍是左值
20. std::move：显式将左值转换为对应的右值类型，调用move意味着之后只能对其销毁或赋值
21. 移动操作：第一个参数是非const右值引用，移动后源对象会被销毁，这意味着它必须可析构；定义了移动操作，则必须定义自己的拷贝操作，因为合成的拷贝操作会被认为是删除的
22. noexcept：声明和定义不抛出异常的移动构造函数和移动赋值函数都要显式指定noexcept，否则系统会使用拷贝操作
23. 合成的移动操作：没有任何自定义的拷贝控制成员，且每个非stastic数据成员都可以移动时，编译器才会为他们合成移动构造函数或移动赋值运算符
24. 移动和拷贝：编译器使用普通的函数匹配规则确定使用哪个拷贝控制成员；通常拷贝左值，移动右值；如果没有移动构造函数，右值也被拷贝
25. std::make_move_iterator：将普通迭代器转化为移动迭代器，解引用得到右值引用；与uninitialized_copy结合可调用移动构造替代拷贝构造
26. 引用限定：用来指出一个非stastic成员函数可用于左值（&）或右值（&&）对象；放在参数列表或const之后可区分重载版本；同名同参数列表的函数必须都加引用限定符或都不加

# 重载运算与类型转换

1. 重载运算符：至少含有一个类类型参数，除函数调用运算符外都不能含有默认实参；优先级、结合律、运算对象个数与内置版本一致；返回类型通常和内置版本兼容；可以像普通函数一样显式调用
2. 不重载的运算符：多数可以重载，除了（:: .* . ?:）；不应该重载逗号、取地址（具有特殊含义），不应重载逻辑与逻辑或（无法保留求值顺序）
3. 是否重载为成员：改变成员状态或与给定类型密切相关应为成员函数，左侧运算对象必须是运算符所属类的一个对象；具有对称性的通常设计为普通非成员函数
4. 重载IO：必须为非成员函数，输出应减少格式化操作，输入能够在出错时将对象恢复
5. 算术运算符：若类含有算术或位运算符，最好也定义复合赋值运算符，前者用后者实现
6. 关系运算符：相等和不等应将其一工作委托给另一个；当两个对象不等时，必须能够用关系运算符比出大小
7. 赋值运算符：拷贝赋值、移动赋值、使用其它类型作为右侧运算对象（如vector使用花括号的元素列表赋值）
8. 下标运算符：同时定义两个版本，返回普通引用的成员和返回常量引用的常量成员
9. 递增／递减运算符：前置改变值后返回引用，后置版本接受一个额外不被用的值为0的int形参，对象存入临时变量，改变值后返回保存改变前的临时变量的值
10. 成员访问运算符：包括解引用和箭头运算符，箭头运算符一般将工作委托给解引用，通常都定义为const成员
11. 箭头运算符：重载的箭头运算符必须返回类的指针，此时直接执行`(*point).mem`；或返回自定义了箭头运算符的某个类的对象，递归执行`point.operator()->mem`，直到返回指针
12. 函数调用运算符：像函数一样使用类，类包含状态所以比普通函数更灵活，定义了函数调用运算符的类叫函数对象
13. lambda：编译器将lambda表达式翻译成未命名类的未命名函数对象，该类中包含重载的函数调用运算符；lambda默认不改变捕获的变量，所以函数调用运算符是const成员，如果lambda被声明为可变的，则调用运算符不是const；产生的类不含默认构造函数、赋值运算符及默认析构函数
14. 标准库函数对象：一组表示算术运算符、关系运算符、逻辑运算符的类，每个类分别定义了执行命名操作的调用运算符；都是模版类，并可适用于指针判断指向对象
15. 可调用对象：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类
16. 调用形式：指明返回类型和传递给调用的实参类型，如`int(int, int)`
17. 标准库function类：模版类型是调用形式，对象是可调用对象；可将运算符与对应的可调用function对象存入函数表；与旧版本的unary_function和binary_function无关，这两个已经被更通用的bind替代
18. 重载与function：将重载存入function会产生二义性问题，解决方法有存储指针和使用lambda
19. 类型转换运算符：没有显式返回类型、没有形参的const成员函数；可以面向除void外的任意可作为函数返回值的类型定义
20. 显式类型转换运算符：开头添加explicit关键字，避免隐式转换导致的异常；但如果表达式被用作条件，仍然被隐式执行；想bool的转换一般被定义为explicit operator bool()
21. 类型转换与二义性：两个类提供相同的类型转换，无法利用本身也面临二义性的强制类型转换解决；类中定义了多个转换源或目标是算数类型的转换；调用重载函数时，若多个定义的类型转换都提供了可行匹配，它们一样好；类可转化为算术类型，并重载了运算符；运算符调用不能通过调用形式区分成员和非成员

# 面向对象程序设计

1. 面向对象程序设计（OOP）：数据抽象（分离接口和实现）、继承（相似类型建模）、动态绑定（忽略相似类型区别）
2. 虚函数：基类希望派生类定义自己版本的函数，声明的返回类型前加virtual；虚函数在派生类中隐式为虚函数，可不加virtual；每个派生类中用于覆盖的虚函数，在声明后必须定义；声明时可在形参列表后加override编译检测
3. 类派生列表：冒号后紧跟以逗号隔开的直接基类列表，每个基类前有访问说明符以控制访问
4. 动态绑定：使用基类的引用或指针调用虚函数时，函数的版本在运行时根据动态类型决定
5. 派生类构造函数：每个类控制自己成员的初始化，派生类必须使用基类的构造函数初始化基类部分，没有显示初始化的部分都会执行默认初始化
6. 静态成员：整个继承体系中只存在静态成员的唯一定义
7. 派生类声明：声明语句的目的是令程序知晓某个名字的存在及它是怎样的实体，所以派生类声明不包含派生列表；一个类作为基类前，一定要定义而非仅声明
8. 防止继承：在类名或函数形参列表后加final关键字，可防止其他类再继承它
9. 派生类转基类：引用、内置指针和智能指针都支持派生类向基类的转换；编译时可知的为静态类型，运行时动态绑定变量在内存中的动态类型
10. 基类转派生类：含有虚函数的基类可使用dynamic_cast在运行时请求转换为指定派生类，确定安全可转换的使用static_cast强制覆盖掉编译器的检查工作
11. 转换规则：只对指针和引用有效，可能因访问受限无法转换；由于大多类定义了拷贝控制成员，将派生类对象也可转为基类对象，但派生部分会被切掉，只处理基类部分
12. 覆盖：派生类中与基类中形参和返回类型相同的函数可覆盖基类函数，一个例外是返回类型是指针或引用且可发生类型转换
13. 虚函数的默认实参：实参值由本次调用的静态类型决定
14. 作用域运算符：回避虚函数的动态绑定机制，覆盖原有的查找规则，指定某个版本的虚函数
15. 纯虚函数：类内函数声明语句后加=0，定义与否皆可
16. 抽象基类：含有或未经覆盖直接继承纯虚函数的类，负责定义接口给后续类覆盖；不能直接创建抽象基类的对象
17. 重构：重新设计类的体系以便移动操作或数据，必须重新编译
18. 受保护成员：类使用protected声明那些希望与派生类共享但不想被其他公共访问使用的成员；派生类的成员或友元只能通过派生类对象来访问基类的受保护对象，不能通过基类
19. 访问权限：受基类中成员和派生列表中访问说明符共同影响；struct默认公有继承，class默认私有继承；派生访问说明符对派生类成员及友元能够直接访问基类成员不影响，只会控制派生类用户（包括派生类的派生类）对基类成员的访问权限
20. 向基类转换的可访问性：只有当可以访问基类的公有成员时，决定派生类向基类的转换才是可访问的
21. 类的用户：边写代码使用类的普通用户只能访问公有成员，负责编写类成员和友元的实现者还能访问私有（实现）部分
22. 友元关系：不能传递，不能继承；每个类负责控制各自成员的访问权限
23. 改变可访问性：派生类可为那些它可以访问的名字提供using声明，置于期望的成员访问说明符后；构造函数的using声明不改变构造函数访问级别；using指定explicit或constexpr无效
24. 隐藏：派生类作用域嵌套在基类作用域内，所以派生类中定义的成员隐藏同名的基类成员
25. 名字查找与继承：确定对象的静态类型；再在本类和基类向上递归查找同名函数；找到后进行类型检查是否调用合法；合法则看调用的是不是虚函数，是虚函数则根据动态类型确定运行版本，不是虚函数或通过对象调用的则产生常规函数调用
26. 覆盖重载函数：一条基类成员函数的using声明可以把该函数所有的重载实例添加到派生类作用域中，此时派生类只需定义其特有的函数
27. 虚析构函数：基类的析构函数如果不是虚函数，delete指向派生类的基类指针将产生未定义
28. 合成拷贝控制：对直接基类部分拷贝后，再拷贝类本身的成员；销毁本身后再销毁基类，基类部分会自动销毁；基类是否是合成版本无影响，只要对应成员可访问且不是删除的函数
29. 移动操作：基类多有虚析构函数，所以不会合成移动操作，如果确实需要应首先在基类中显式定义，此时要同时显式定义拷贝操作
30. 定义拷贝操作：基类默认构造函数初始化派生类对象的基类部分，如果想拷贝或移动基类部分，则需要在派生类的构造函数初始值列表中显式使用基类的拷贝或移动构造函数析构；自定义的析构函数只负责销毁派生类自己分配的资源；构造或析构函数调用了虚函数，则应该执行与其所属类型对应版本的虚函数
31. 继承的构造函数：类不能继承默认、拷贝和移动构造函数，如果没有直接定义则编译器会合成它们，即使继承了基类的其他构造函数；派生类数据成员将被默认初始化
32. 基类构造含默认实参：派生类将获得多个继承的构造函数，每个分别省略掉一个有默认实参的形参
33. 容器与继承：容器中应放置（智能）指针而非对象
34. 继承与组合：派生类应反映与基类的Is A关系，公有派生类的对象应该可以用在任何需要基类对象的地方；类型之间Has A则暗含成员的意思
35. 接口类：在抽象基类中声明一个接口类的友元，接口类中包含该抽象基类指针，负责隐藏整个继承体系

# 模版与泛型编程

1. 动态类型：面向对象编程在运行时确定类型，泛型编程在编译时获知类型
2. 模版：泛型编程基础，一个创建类或函数的蓝图，适用于编译时才确定类和函数类型的情况
3. 模板定义：以template开始，后跟尖括号包围的模板参数列表，内含一个或多个由逗号分隔的模板参数
4. 实例化函数模板：调用模板时，隐式或显示的指明模板实参，实例化出一个特定版本的称为实例的函数
5. 模板参数：类型参数可看作类型说明符，跟在class或typename关键字之后；非类型参数表是一个值，通过特定类型名指定，可以是常量表达式的整型，或具有静态生存期的指针或引用
6. 泛型代码原则：尽量减少对实参类型的要求，函数参数是const引用，条件判断仅用<比较运算
7. 模板编译：由于实例化时需要掌握函数模版和类模版成员函数的定义，其定义通常也放在头文件中，与普通函数和普通类成员函数不同
8. 实例化类模板：必须提供显式模板实参，每种元素类型生成的各个实例类之间无关联，拥有各自的static成员
9. 类模版成员函数：定义在类外需用template开始，后跟类模版参数列表；实例化了的类模板，其成员只有在用到时才实例化
10. 类模板和友元：非模板友元被授权访问所有类模板实例，模板友元可根据声明访问特定实例或所有实例
11. 模板类型别名：不能用typedef引用模板，新标准可使用using定义别名，如`template <typename T> using partNo = pair<T, unsigned>; parNode<string> books; partNo<Student> kids;`
12. 模板参数作用域：在模板内不能重用模板参数名，正常的名字隐藏规则依旧适用；用作用域运算符访问类的类型成员时，需在句首加typename关键字，否则会被默认为static成员
13. 默认模板实参：就标准只允许类模板有默认实参，新标允许函数模板也有默认实参；调用类模板时必须加上尖括号，即使所有参数都有默认值
14. 成员模板：无论普通类还模板类中，本身是模板的成员函数叫成员模板，不能是虚函数；在类模板外定义成员模板，必须同时为两者提供模板参数列表
15. 显式实例化：避免相同模板参数产生多个实例导致的额外开销；可用extern多次声明实例，但必须有且仅有一次定义；编译器会实例化该类的所有成员，所以显式实例化提供的类型必须能用于所有成员
16. 智能指针的删除器：shared_ptr保存删除器指针，方便运行时传递可调用对象重置；unique_ptr中包含显式实例化的删除器成员，避免间接调用删除器时的运行开销
17. 类型参数转换：通常不转换而是生成一个新的模板实例；有限可用的转换规则包括const转换和数组或函数指针转换；非模板类型参数正常转换
18. 显式模板实参：在函数之后，实参列表前用尖括号提供显式实参；只有尾部的显式模板实参，并且可从函数参数推断出来的时候，才可忽略；显式指定的实参可正常类型转换
19. 尾置返回类型：需要根据传入的参数确定返回类型时，可通过decltype推断形参作为返回类型，使用尾置返回类型格式返回
20. 标准库类型转换模板：定义在头文件type_traits中，每个模板有一个公有成员type用于转换，不能转换时则返回模板参数类型本身；如remove_reference可将T&、T&&、T转换为T
21. 函数指针：用函数模板初始化函数指针时，根据指针的类型推断模板实参；使用显式模板实参消除二义性
22. 引用折叠：间接创建引用的引用，除右值引用的右值引用折叠为右值引用，其他3种引用的引用都折叠为左值引用
23. 右值引用形参：可传给它任意类型的实参，若传引用也不改变左／右值属性；通常用于模板转发实参或模板重载；使用右值引用的函数模板通常重载绑定非const右值引用或const左值引用
24. 转发：函数参数指向模板类型参数的右值引用，可保持对应实参的const属性和左／右值属性；进一步为解决接受右值引用参数不被理解为左值的问题，使用utility头文件中定义的forward，返回显式实参的右值引用，可保持实参类型的所有细节
25. 函数模版匹配：候选函数包括所有模板实参推断生成的实例，模板和非模板的可行函数统一按类型转换排序，多个函数同样好则顺次选择唯一的非模板函数、无非模板函数时最特例化的模板函数，否则调用有歧义
26. 可变参数模板：接受可变数目参数的模板函数或模板类；`class...、typename...、type-name...`指定参数包，之后跟零个或多个参数，用`sizeof...(args)`获取参数个数；如`template <typename… Args> void foo(const Args& … args)`中，Args是模板参数包，args是函数参数包
27. 可变参数函数模板：可变参数函数通常是递归的，非可变参数版本的声明必须在作用域内，否则无限递归
28. 包扩展：将一个包分解为多个元素，并对每个元素应用模式，通过在模式后添加省略号触发
29. 转发参数包：参数定义为右值引用 `foo(Args&&… args)`，转发时应用forward模式 `bar(std::forward<Args>(args)…)`
30. 函数模板特例化：必须为每个模板函数提供实参，关键字template后跟一对空的尖括号；特例化的本质是实例化，而非重载，因此不影响函数匹配
31. 特例化与作用域：所有同名模板的声明应放在同一头文件的前面，在该文件内再接着声明这些模板的特例化版本。
32. 类模板特例化：若不指定全部参数部分特例化，则得到的是模板，所以要先定义模板参数；也可以事先只特例化特定成员函数，之后调用相同类型时则会调用该特例化函数而非重新实例化该成员函数
33. 无序容器与特例化：无序容器会组合使用关键字类型对应的特例化hash版本，和关键字类型上的相等运算符


---


***转载请注明出处***
