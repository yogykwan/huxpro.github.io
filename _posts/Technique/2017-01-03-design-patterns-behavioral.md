---
layout:     post
title:      "大话设计模式之行为型"
subtitle:   ""
date:       2017-01-03
author:     "Jennica"
header-img: "img/post-bg-patterns.jpg"
catalog: true
tags:
    - 技术
    - 读书
    - 架构
---

# 前言

## 行为型模式
GoF的23种设计模式中，行为型模式通过一组对象的互相协作完成单个对象无法完成的任务，共11种：

- 职责链模式
- 策略模式
- 状态模式
- 观察者模式
- 迭代器模式
- 备忘录模式
- 命令模式
- 模板方法模式
- 中介者模式
- 解释器模式
- 访问者模式

## 案例实现

- [《大话设计模式》C++版](https://github.com/yogykwan/design-patterns-cpp)
- [《大话设计模式》Python版](https://github.com/yogykwan/design-patterns-py)

# 职责链模式（Chain of Responsibility）

1. 职责链模式：使多个对象都有机会处理请求，解除请求发送者和接收者的耦合。将对象连成一条链，并沿这条链传递请求直到请求被解决。
2. 请求交付给最小接受者，职责链中每一环保存后继的引用，使得请求有序沿链传递。
3. 通过合理设置后继以及分支关系，避免一个请求到了链末端依旧无法被处理，或因配置错误得不到处理的情况。

# 策略模式（Strategy）

1. 面向对象中并非类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。
2. 策略模式：定义算法家族并分别封装，他们完成的工作相同，只是实现不同，可以互相替换。继承有助于析取这些算法的公共功能。此模式让算法的变化不会影响到使用算法的用户。
3. 策略与工厂模式结合，使客户端需要认识的类减少，耦合度更加降低。
4. 策略模式可以简化单元测试，因为每个算法可以通过自己的接口单独测试。
5. 只要在不同时间内应用不同的业务规则，就可以考虑用策略模式来处理这种变化的可能性。

# 状态模式（State）

1. 拥有过多分支的过长方法违背了单一职责原则，而且当需求变化时修改代码往往会违背开放-封闭原则，应该将分支变成一不同小类，将状态的判断逻辑转移到小类中。
2. 状态模式：一个对象可能拥有多种状态，当内在状态改变时允许改变行为。
3. 状态模式的好处是将与特定状态有关的行为局部化，并将不同状态的行为分隔开。

# 观察者模式（Observer）

1. 观察者模式：多个观察者对象同时监听某一主题（通知者）对象，当该主题对象状态变化时会通知所有观察者对象，使它们能更新自己。
2. 具体观察者保存一个指向具体主题对象的引用，抽象主题保存一个抽象观察者的引用集合，提供一个可以添加或删除观察者的接口。
3. 抽象模式中有两方面，一方面依赖另一方面，使用观察者模式可将两者独立封装，解除耦合。
4. 观察者模式让主题和观察者双方都依赖于抽象接口，而不依赖于具体。
5. 委托就是一种引用方法类型。委托可看作函数的类，委托的实例代表具体函数。在主题对象内声明委托，不再依赖抽象观察者。
6. 一个委托可以搭载多个相同原形和形式（参数和返回值）的方法，这些方法不需要属于一个类，且被依次唤醒。

# 迭代器模式（Iterator）

1. 迭代器模式：提供一种方法顺序遍历一个聚集对象，为不同的聚集结构提供遍历所需接口，而不暴露对象内部的表示。
2. 在高级编程语言如c#、c++、java等，都已经把迭代器模式设计进语言的一部分。
3. 迭代器模式分离了对象的遍历行为，既不暴露内部结构又可以让外部代码透明的访问集合内部的数据。

# 备忘录模式（Memento）

1. 备忘录模式：不破坏封装，获取对象内部状态并在其之外保存该对象，以便其未来恢复到当前状态。
2. Orginator负责创建Memento，Memento封装Originator状态细节，Caretaker负责保管和交付Memento。
3. 备忘录模式适用于需要维护历史状态的对象，或只需要保存原类属性中的小部分。

# 命令模式（Command）

1. 命令模式：将请求分装为对象，将请求和执行分开，可以用不同的请求对客户参数化。可以对请求排队、通过或否决、记录日志、撤销或重做。
2. 基于敏捷开发原则，不要给代码添加基于猜测而实际不需要的功能，在需要的时候通过重构实现。

# 模板方法模式（Template Method）

1. 模板方法模式：定义一个操作中的算法框架，将一些步骤延迟到子类中。子类在不改变框架的前提下就可以重新定义某些特定步骤。
2. 当不变和可变的行为在子类中混到一起时，可以通过把重复的行为移到同一地方，帮助子类摆脱重复不变行为的纠缠。

# 中介者模式（Mediator）

1. 中介者模式：用一个中介对象来封装一系列对象间的交互。
2. 中介者模式在系统中易用也容易被误用，当系统中出现了多对多的交互复杂的对象群时，更应考虑设计的问题。
3. 由于控制集中化，中介者模式将交互复杂性变成了中介者的复杂性，中介者类会比任何一个同事类都复杂。
4. 中介者模式应用的场合有，一组对象以定义良好但复杂的方式进行通信，以及想定制一个分布在多个类中的行为却不想产生太多子类。

# 解释器模式（Interpreter）

1. 解释器模式：给定一种语言，定义它文法的一种表示，再定义一个解释器，使用该表示来解释语言中的句子。
2. 如果一种特定类型发生的频率足够高，就可以将其实例表达为一个句子，构建解释器来解析。
3. 解释器模式就是用“迷你语言”来表现程序要解决的问题，将句子抽象为语法树。由于各个节电的类大体相同，便于修改、扩展和实现。
4. 解释器为文法中的每条规则定义了一个类，当文法过多时将难以维护，建议使用其他技术如语法分析程序或编译器生成器处理。

# 访问者模式（Visitor）

1. 访问者模式：在不改变各元素的前提下定义作用于这些类的新的操作。
2. 访问者模式使用双分派，将数据结构和作用于结构上的操作解耦，意味着执行的操作决定于请求的种类和接收者的状态。
3. 如果系统具有较为稳定的数据结构，又有易于变化的算法操作，则适合使用访问者模式。

# 对比总结

- 职责链模式：按顺序让负责的对象们依次处理；
- 策略模式：将算法族抽象封装；
- 状态模式：将复杂的状态转移方式下发到每个状态内部；
- 观察者模式：发布和订阅；
- 迭代器模式：遍历容器；
- 备忘录模式：在对象之外备份及恢复；
- 命令模式：封装请求与执行分开；
- 模板方法模式：提炼共有方法。
- 中介者模式：用中介对象封装交互。
- 解释器模式：迷你语言；
- 访问者模式：解耦数据结构及操作。


---


***转载请注明出处***