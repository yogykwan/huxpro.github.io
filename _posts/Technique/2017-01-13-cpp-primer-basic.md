---
layout:     post
title:      "C++ Primer：C++基础"
subtitle:   ""
date:       2017-01-13
author:     "Jennica"
header-img: "img/post-bg-cpp.jpg"
catalog: true
tags:
    - 技术
    - 读书
    - C++
---


> 重走C++整洁之道。

# 前言

把[《C++ Primer》](https://book.douban.com/subject/25708312/)读薄系列笔记，第I部分：C++基础。

## 目录

[第I部分：C++基础](http://jennica.space/2017/01/13/cpp-primer-basic/)

1. 开始学习C++
2. 变量和基本类型
3. 字符串、向量和数组
4. 表达式
5. 语句
6. 函数
7. 类

[第II部分：C++标准库](http://jennica.space/2017/01/23/cpp-primer-stl/)

8. IO库
9. 顺序容器
10. 范型算法
11. 关联容器
12. 动态内存

[第III部分：类设计者的工具](http://jennica.space/2017/03/14/cpp-primer-ood/)

13. 拷贝控制
14. 重载运算与类型转换
15. 面向对象程序设计
16. 模版与泛型编程

## 题解
修订版**课后题解**见GitHub仓库：[cpp-primer-workbook](https://github.com/yogykwan/CppPrimer)。

# 开始学习C++

1. main的返回值：0为成功状态，非0为系统定义的错误类型
2. 编译：

    | 编译器 | 系统环境 | 编译 | 运行 | 获取返回值 |
    | --- | --- | --- | --- | --- |
    |VS|Windows|`c1 /EHsc /W4 prog1.cc`|`prog1`|`echo %ERRORLEVEL%`|
    |GNU|Unix|`g++ -std=c++11 -Wall prog1.cc`|`./a.out`|`echo $?`|
3. 输入输出：计算结果为左侧运算对象，IO操作读写缓冲与程序中的动作无关
4. 输入流istream对象：cin（标准输入）；流状态有效则cin为真，遇到EOF或无效输入cin为假
5. 键盘输入EOF：Windows下ctrl+d->return，Unix下ctrl+d
6. 输出流ostream对象：cout（标准输出）、cerr（警告错误、不缓冲）、clog（一般性信息、缓冲）
7. 操纵符endl：结束当前行，并将缓冲区内容刷到设备中，调试时的打印应保证一直刷新流
8. 缓冲刷新：默认情况下，cin和cerr会刷cout缓冲，程序异常终止cout不会被刷新
9. 命名空间：避免相同名字导致的冲突，调用标准库需显式说明作用域std::
10. 文件重定向：将标准输入输出与文件关联，运行命令 `prog1 <infile >outfile`


# 变量和基本类型

1. 空类型（void）：无值无操作，不能定义void类型变量
2. 字符类型：char为UTF-8编码，wchar_t是确保机器可以存储及其最大扩展字符集中的任何字符的宽字符，char16_t和char32_t对应Unicode字符集
3. 内置类型的机器实现：地址表示比特串开始位置，类型决定了数据所占的比特位数及如何解释其内容
4. 浮点数：float和double分别有7和16个有效位，通常选用double，避免float的低精度及long double的低效率
5. 未定义（undefined）：引发难以追踪的运行时的错误、安全问题、移植性问题
6. 赋值超范围：对无符号类型是初始值对无符号类型表示数值范围取模后的余数，而带符号类型结果是未定义
7. 有无符号类型混用：表达式中同时包含带符号和无符号类型，带符号数会自动转为无符号数
8. 整型字面值：十进制字面值默认为带符号数，是int/long/long long 中能容纳其值且尺寸最小。八进制（0开头）和十六进制（0x开头）则是int/unsigned int/unsigned long/long long/unsigned long long中尺寸最小者
9. 浮点型字面值：小数或科学计数法形式的指数，默认类型double
10. 字符串字面值：编译器在每个字符串结尾添加空字符'\0’
11. 字符前缀与类型：u（char16_t），U（char32_t），L（wchar_t），u8（char）
12. 泛化的转义序列：\x后跟十六进制数字，或\后跟1到3位八进制数字，可像普通字符一样使用
13. 列表初始化：使用花括号初始化，当存在丢失信息风险时编译器将报错，而使用()可以执行但可能发生信息丢失
14. 初始化：定义在任何函数之外的变量被初始化为0，每个类决定各自的初始化对象方式。而定义在函数体内部的内置变量类型将不初始化，试图访问未初始化的值将引发未定义行为
15. 定义：负责创建与名字关联的实体，并申请存储空间和赋初始值
16. 声明：规定变量的类型和名字，只声明不定义可在变量名前添加extern并不显式初始化，包含显式初始化即为定义
17. 引用：为对象起的别名，定义时必须初始化，不是对象，不可定义引用的引用
18. 指针：指向某个对象，定义时无需赋值，本身就是对象，对指针使用解引用符*可访问该对象
19. 指针值状态：指向一个对象、指向对象的下一个紧邻空间位置、空指针、无效指针（访问或拷贝都会出错）
20. 空指针（nullptr）：不指向任何对象，可以转换成任何其他的指针类型
21. 初始化指针：建议用已定义对象或nullptr或0初始化所有指针，把任何int型变量（即使值为0）赋值给指针是错误的
22. void*指针：可存放任意对象的地址，但不能直接操作其所指对象
23. 引用／指针类型匹配：除两种特例（const可绑定非const，基类可绑定派生类）外，指针和引用的类型都需要与之绑定的对象严格匹配
24. 复合类型判断：从右向左阅读复杂的指针或引用的声明语句，离变量名越近的符号对变量的类型有越直接的影响
25. 多文件共享const：不管声明还是定义都要添加关键字extern
26. 初始化对const的引用：允许任何表达式作为初始值，只要该表达式结果可以转化为引用类型的临时量对象
27. 指向常量的指针：自觉不去改变所指对象的值，而该对象若不是常量对象则其值通过其他方式改变
28. const指针：必须初始化且不能修改，书写上直接在变量名之前，表示不变的是指针本身而非指针指向的对象
29. 顶层／底层const：顶层const表示本身是常量，底层const表示绑定的对象是常量；执行拷贝操作时，拷入拷出对象必须具有相同的底层const资格，或能够强制转换
30. 常量表达式：数据类型和初始值都需要是常量类型，值不会改变并在编译过程就能得到计算结果
31. constexpr变量：一定是常量，必须用常量表达式（字面值类型，包括算术类型、引用、指针）或constexpr函数（足够简单编译时可计算结果）初始化
32. constexpr指针：初始值是nullptr或0，或存储于某个固定地址中的对象
33. 指针、常量与类型别名：`typedef char *pstring; const pstring cstr = 0;`，与`const char *cstr`不等价，前者的cstr是指向char的常量指针，后者中cstr是指向常量char的指针
34. 类型说明符auto：让编译器通过初始值推算变量类型，并赋诸该值；忽略顶层const，保留底层const
35. 类型指示符decltype：让编译器通过初始值推算变量类型，但不用该初始值赋值；包含顶层const，解引用、(())、赋值产生的引用都会判为引用类型
36. 预处理器：在编译前执行的一段程序，功能有替换#include的头文件，以及头文件保护符避免重复定义实体
37. 预处理变量：#define将一个名字设置为预处理变量，#ifndef及#ifdef则判断名字是否已被定义过，无视作用域规则

# 字符串、向量和数组

1. using声明：每个using声明引入命名空间的一个成员；头文件中的代码一般不应使用using声明
2. string初始化：用数字和字符初始化，则string对象内容是将给定字符连续重复给定次数得到的序列
3. getline：从输入流中读入内容直到读入换行符，保留空白符，但换行符不存入string对象中
4. 字面值与string：字符字面值和字符串字面值可以转化为string对象，相加时加号两侧的运算对象至少有一个是string型
5. C++版的C头文件：C++版本的C标准库头文件中，定义的名字从属于命名空间std，对应的C语言的.h文件则不然
6. size_type：string::size_type和vector::size_type可表示各自类型的长度或下标，无符号整数
7. 实例化：根据模版创建类或函数的过程，必须指明实例化成何种类型
8. 初始化特例：拷贝初始化时只能提供一个初始值；类内初始值只能使用拷贝初始化或花括号；初始元素值的列表只能放在花括号内
9. 值初始化：通常使用圆括号；但如果使用花括号但提供的值又不能用来列表初始化时，编译器也会尝试用值初始化
10. vector比较：当元素的值可比较时，按照字典顺序进行
11. 下标运算符：vector或string的下标运算符可用于访问已存在的元素，而不能用于添加元素
12. 迭代器成员：begin和end运算符的具体类型由对象是否是常量决定，cbegin和cend始终得到const_iterator
13. 迭代器比较：两个迭代器，指向同一容器中的元素或尾元素的下一位置，比较的是位置的前后；相减得到different_type型的有符号整数，表示两个迭代器的距离
14. 定义数组：必须指定数组类型，不能使用auto由初始值推断；类型不能是引用
15. 字符数组：可以使用字符串字面型初始化，数组中需要空间放空字符
16. 复杂数组声明：从数组名字开始按照由内向外的顺序阅读，如`int *(&a)[10]`表示a是对数组引用，该数组包含10个int*
17. 数组下标：通常定义为无符号类size_t类型，但与标准哭类型不同的是，数组允许负数作为下标
18. 数组与指针：多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针
19. 首指针和尾后指针：使用标准库函数begin()和end()可以得到数组的首指针和尾后指针；提供这两个指针可以将数组拷贝初始化vector对象；尾后指针不指向具体元素，不能解引用或递增
20. 指针比较：只要两个指针指向同一个数组的元素或尾元素下一个位置，就能用关系运算符比较前后；两个指针相减的结果类型是有符号类型ptrdiff_t
21. string转char*：`s.c_str()`函数将string对象s，转化为一个C风格的字符串，但无法避免s改变后之前返回的字符串失去效用
22. 多维数组初始化：使用花括号的形式，未列出的元素执行默认值初始化
23. 范围for处理多维数组：除最内层循环外，其他所有循环的控制变量都应该是引用类型，以避免这些数组形式的元素被自动转换成指向数组首元素的指针
24. 多维数组指针：多维数组的指针是指向内层数组的指针；避免指针类型混淆可使用auto或decltype，begin()和end()，类型别名简化多维数组的指针


# 表达式

1. 左值右值：左值用的是对象的身份，右值用的是对象的值
2. 求值顺序：未指定执行顺序的表达式，如果指向并修改同一个对象，会引发错误产生未定义；只有4种运算符规定了从左到右的求值顺序（条件与`&&`、条件或`||`、条件运算符`?:`、逗号`,`）
3. 整数相除：商向0取整；取余时m%(-n)=m%(n)，-m%n=-(m%n)
4. 真值测试：比较运算中除非比较对象是bool型，否则不使用布尔字面值
5. 值初始化：无论左侧运算对象是什么类型，初始值列表都可以为空，编译器会创建值初始化的临时量赋给左侧运算对象
6. 复合赋值运算符：只求值1次，普通运算符需要2次（右边表达式和赋值）
7. 整型提升：小整型（如short、char）总会自动提升为较大的整型，一般为int；较大的char（如w_char）提升为大整型中可容纳原值的最小一类
8. 移位运算符：右侧的移动位数必须非负且小于结果的位数；移出位被舍弃，符号位视机器而定
9. sizeof运算符：可使用作用域来获取类成员大小，可使用无效的指针获取指针指向的对象所占空间，不会把数组当指针处理，对string或vector返回固定部分的大小；sizeof的返回值是常量表达式
10. 逗号运算符：先对左侧表达式求值，然后丢弃求值结果，真正的结果是右侧表达式的值
11. 数组指针转换：大多时候会自动隐式转换；当数组被当作decltype、&、sizeof、typeid的运算对象时，转换不发生
12. 指针的转换：0或nullptr可转换成任意指针类型，非底层const的指针可以转为`void*`，底层const的指针可以转为`const void*`
13. 命名的强制类型转换：static_cast（无底层const）、dynamic_cast（运行时类型识别）、const_cast（有底层const）、reinterpret_cast（低层的重新解释）

# 语句

1. switch语句：对括号内表达式求值转换为整数类型，然后与case后的每个常量表达式比较
2. default标签：当其他case都不满足时执行，位置自由，若为空也必须跟上一个空语句（ ;）或空块（{}）
3. 控制流跳转：在switch和goto中，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置
4. 范围for语句：语法形式是`for (declaration: expression) statement`；expression表示一个可以返回迭代器的begin()和end()的序列，不允许增删容器元素改变范围for中预存的end()值
5. 异常：throw引发异常，try中跑出的异常通过会被某个catch处理，在throw与catch间通过异常类传递信息
6. 寻找异常处理代码：寻找异常处理代码的过程与函数调用相反，逐层回退直到找到适当类型的catch子句；若最终未找到则会转到terminate的标准库函数，全无try语句的程序会直接调用terminate
7. 异常安全：确保对象有效，资源无泄漏，程序处于合理状态，等等
8. 异常类：头文件exception中的exception类、stdexcept中定义了几种常见的异常类、new中的bad_alloc、type_info中的bad_cast
9. 异常类初始化：exception、bad_alloc、bad_cast只允许默认初始化，what()返回编译器决定的异常信息；标准异常类必须使用string或C风格字符串初始化，what()返回该串

# 函数

1. 函数参数：实参是函数中形参的初始值，存在对应关系，但并没有规定实参的求值顺序
2. 局部静态对象：不同于只存在于块执行期间的自动对象，局部静态对象直到程序终止才被销毁；没有显式初始值时会执行值初始化
3. 函数声明：函数可以只能声明一次，但可以定义多次，如果一个函数永远不会被用到，可以只声明不定义
4. const参数：实参初始化形参时会忽略顶层const，所以有无顶层const版本等价，都定义则属于重复定义
5. 数组实参：不允许拷贝数组，传递数组时实际上是传递指向首元素的指针；不同大小的数组是不同类型；若形参是引用，数组不会转换为指针
6. 传多维数组：数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略
7. initializer_list：实参数量未知但类型都相同，initializer_list可作形参；提供的操作类似容器，但对象中的元素永远是常量
8. 省略符形参：出现在形参列表的最后一个位置，形式为`f(…)`或`f(t,…)`；大多类类型对象传递给省略符形参时无法正常拷贝
9. 返回引用：不要返回局部对象的引用或指针，调用一个返回引用的函数得到左值
10. 列表初始化返回值：函数可以返回花括号包围的值的列表；若返回为内置类型，则花括号内至多一个值，而且所占空间不应大于目标类型空间
11. main的返回值：控制到了main的结尾仍无return语句，编译器隐式插入`return 0;`；头文件cstdlib中定义了预处理变量EXIT_FAILURE和EXIT_SUCCESS表示成败
12. 返回数组指针：形如`Type (*function(parameter_list))[dimension]`，函数返回类型是指向大小为dimension的数组的指针
13. 尾置返回类型：形如`auto function(parameter_list) -> Type (*)[dimension];`
14. decltype确定返回类型：把左值转换为引用；由于decltype不负责把数组或函数类型转换为对应指针，所以函数声明时要加一个星号
15. main函数：不能调用自己，不能重载
16. const_cast和重载：常用const_cast修改const参数属性的性质，将const和非const版本的重载函数关联
17. 重载与作用域：名字查找发生在类型检查前，所以在不同作用域无法重载函数名，且内层将隐藏外层声明的同名函数
18. 形参默认值：被赋予了默认值的形参，后面所有形参都必须有默认值；在给定的作用域中一个形参只能被赋予一次默认值；可多次声明函数给不同形参赋予默认值
19. 内联函数：一般只有当函数规模小、流程直接、无递归时，内联函数的请求才会被编译器接受
20. constexpr函数：能用于常量表达式的函数，但返回值可以是非常量；返回和形参类型都是字面值类型，函数只执行一句return；被隐式指定为内联函数；
21. 内联定义：和其他函数不同，内联和constexpr函数可以多次定义，但每次必须完全一致，通常定义在头文件中
22. 预处理宏assert：根据提供的表达式判断是否要输出错误信息并终止程序，可定义预处理变量NDEBUG禁用assert的效果
23. NDEBUG：可在`#ifndef NDEBUG`和`#endif`之间编写自己的调试代码；有5个编译器预定义的名字变量`__func__/__FILE__/__LINE__/__TIME__/__DATE__`，用于输出调试信息
24. 函数匹配：先选择在调用点可用的同名候选函数，再找到参数数量相等且类型相同或可强制转换的可行函数，再寻找其中最佳匹配的函数
25. 最佳匹配：每个实参的匹配都不劣于其他可行函数，且至少有一个优于其他；若找不到最佳匹配则报二义性错误
26. 实参类型转化优先级：精确匹配>const转换>类型提升>算术类型或指针转换>类类型转换
27. 函数指针：声明指向一个函数的指针，只需要用指针替换函数名；将函数名当作值使用时会自动转换成指针
28. 重载函数的指针：指针类型必须与重载函数中的某一个精确匹配
29. 函数指针形参：函数声明中，若形参是函数类型，则它会自动转换成指向函数的指针

# 类

1. 数据抽象：定义数据成员和函数成员，抽象数据类型依赖封装
2. 封装：分离接口（用户所能执行的操作）和实现（数据成员、实现接口的函数体、私有函数）
3. 成员函数：声明必须在类内部，但定义可在类内或外，定义在类内部的函数是隐式的inline函数
4. this：指向类类型非常量版本的常量指针，所以不能在常量类对象上调用普通成员函数
5. 常量成员函数：参数列表后带const的函数叫常量成员函数，它可将this设置为指向常量的指针，使得常量对象可访问常量成员函数，但不可写入新值；若以引用形式返回*this，则返回类型是常量引用
6. 合成的默认构造函数：会尽可能使用类内初始值初始化数据成员，当类不存在任何构造函数时编译器创建的默认构造函数；既需要其他形式又需要合成的默认构造函数，可在默认构造函数的参数列表后面加上`= default`
7. 类的动态内存：当类需要分配类对象之外的资源时，合成的版本常常会失效；需要动态内存的类应该使用vector或string对象管理存储空间，避免分配和释放内存带来的复杂性
8. class和struct：唯一区别是默认的访问权限，class为private，struct为public
9. 友元：允许其他类或函数访问非公有成员，则可在类的开头用friend关键字将其声明为友元；友元的声明仅仅限定了权限，可在真正的函数声明之后；友元函数可以定义在类的内部，但在类的外部仍然需要提供相应的声明使得函数可见
10. 可变数据成员：添加mutable关键字的数据成员，即使在const成员函数中，依旧可以被改变
11. 类内初始值：必须使用符号或花括号的直接初始化形式
12. 重载const：根据是否是常量对象，决定调用是否是常量版本的成员函数
13. 类的声明：仅声明不定义叫做前向声明：类在声明之后、定义完成之前是不完全类型，可以定义其指针或引用，作为函数的参数或返回值；只有当类全部完成后类才算被定义，所以类的成员中不能包含自己，但可以出现指针或引用
14. 类的定义：编译所有成员的声明之后才会编译函数体
15. 类型名的定义：内层作用域可以重新定义外层作用域的名字，但若外层作用域中的某个名字表示类型，则类中不能再重新定义该名字
16. 访问类成员：使用this->或类名::可强制访问类成员，无视作用域的名字查找规则；无类名加::表示全局对象
17. 成员初始化：若成员是const、引用、无默认构造函数的类，必须通过初始值列表将其初始化
18. 初始化顺序：与类中定义的顺序一致，不受初始值列表中顺序影响
19. 默认构造函数：当对象被默认初始化或值初始化时，自动执行默认构造函数；不那么明显的一种情况是类的某些数据成员缺少默认构造函数
20. 默认初始化场景：无任何初始值定义非静态变量或数组，本身含有类成员且使用合成的默认构造函数，类类型成员没有在构造函数初始值列表中显式初始化
21. 值初始化：初始值数量小于被初始化的数组大小，不使用初始值定义局部静态变量，通过T()表达式显式请求值初始化
22. 默认构造对象：使用默认构造函数定义对象的格式为类名+对象名，无之后空的圆括号对，否则将定义为函数而非对象
23. 类类型转换：构造函数只接受一个实参，则其定义了一种从构造函数的参数类型到类类型的隐式转换规则；编译器只会自动执行一步类型转换
24. 显式构造函数：在类内添加explicit关键字的构造函数只能用于直接初始化，抑制隐式转换；编译器不会在自动转换过程中使用它，但可用于显式的强制转化
25. 聚合类：所有成员public、未定义构造函数、无类内初始值、无基类或virtual函数；使用花括号初始化，花括号内的初始值顺序与声明顺序一致
26. 字面值常量类：数据成员都是字面值类型的聚合类；或数据成员都是字面值类型、至少含有一个constexpr构造函数、类内初始值是常量表达式或拥有自己的constexpr构造函数、使用析构函数的默认定义
27. constexpr构造函数：为保证构造函数的不包含返回语句，和constexpr函数唯一可执行语句即返回函数，其函数体一般为空
28. 静态成员：独立于任何对象之外，不包含this指针；静态成员函数不能声明为const，也不能在内部使用this指针
29. 静态数据成员：必须在类的外部定义和初始化，方式和类外部定义成员函数类似；若静态数据成员为constrexpr类型，且其只限于编译器替换值的使用场景，则可以在类内定义，否则必须在类外再重新定义
30. 静态成员的优势：类内可包含自身类型的静态数据成员，但普通成员只能是指针或引用；静态成员可以作为默认实参，非静态数据成员的值属于对象的一部分，不能作为默认实参



---


***转载请注明出处***