---
layout:     post
title:      "大话设计模式之创建型"
subtitle:   ""
date:       2016-12-28
author:     "Jennica"
header-img: "img/post-bg-patterns.jpg"
catalog: true
tags:
    - 技术
    - 读书
---

# 说明

## 创建型模式
GoF的23种设计模式中，创建型模式讨论的是高效创建对象的问题，共5种：

- 工厂方法模式
- 抽象工厂模式
- 单例模式
- 建造者模式
- 原型模式

## 案例实现

[《大话设计模式》C++版](https://github.com/yogykwan/design-patterns)


# 工厂方法模式（Factory Method）

1. 工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪个类。
2. 工厂方法把简单工厂的内部判断逻辑移到了客户端代码，本来需要修改工厂类，现在是修改客户端。
3. 简单工厂模式违背了开放-封闭原则，工厂方法模式借助多态，克服了该缺点，却保持了封装对象创建过程的优点。

# 抽象工厂模式（Abstract Factory）

1. 抽象工厂模式：提供一个创建一系列相关或互相依赖对象的接口，只需要知道对象的系列，无需知道具体的对象。
2. 在客户端中，具体工厂类只在初始化时出现一次，更改产品系列即可使用不同产品配置。
3. 利用简单工厂类替换抽象工厂类及其子类，可以使客户端不再受不同系列的影响。
4. 结合反射机制，Assembly.Load(“程序集名称”).CreateInstance(“命名空间”.“类名”)，可以直接通过字符串创建对应类的实例。所有在简单工厂中，都可以通过反射去除switch或if，解除分支判断带来的耦合。
5. 反射中使用的字符串可以通过配置文件传入，避免更改代码。

# 单例模式（Singleton）

1. 单例模式：让类自身保证它只有一个实例，并提供一个全局访问点。
2. 多线程下单例模式可能失效，需要采取双重锁定的的方式，确保被锁定的代码同一时刻只被一个进程访问。
3. 饿汉式单例：即静态初始化方式，在类初始化时产生私有单例对象，会提前占用资源；渴汉式单例：在第一次被引用时将自己初始化，会产生多线程访问安全问题，需要添加双重锁定。

# 建造者模式（Builder）

1. 建造者模式：将复杂对象的创建与表示分开，使得相同的创建过程可以有不同的表示。用户只需制定需要建造的类型，不需要知道建造的过程和细节。
2. 指挥者是建造者模式中重要的类，用于控制建造过程，也可以隔离用户与建造过程的关联。
3. 建造者隐藏了产品的组装细节，若需要改变一个产品的内部表示，可以再定义一个具体的建造者。
4. 建造者模式是在当前创造复杂对象的算法，独立于该对象的组成部分和装配方式时适用的模式。

# 原型模式（Prototype）

1. 原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建对象。本质是从一个对象再创建另一个可定制的对象，并且不需要知道创建细节。
2. 原型抽象类的关键是有一个Clone()方法，原型具体类中复写Clone()创建当前对象的浅表副本。
3. 对.Net而言，由于拷贝太常用原型抽象类并不需要，在System命名空间中提供了ICloneable接口，其中唯一的方法就是Clone()，只要实现这个接口就可以完成原型模式。
4. 原型拷贝无需重新初始化对象，动态获取对象的运行状态。既隐藏了对象创建的细节，又提升性能。
5. 在具体原型类中，MemberwiseClone()方法是浅拷贝，对值类型字段诸位拷贝，对引用类型只复制引用但不会把具体的对象值拷贝过来。
6. 比起浅拷贝，深拷贝把引用对象的变量指向新对象，而不是原被引用的对象。对于需要深拷贝的每一层，都需要实现ICloneable原型模式。
7. 数据集对象DataSet，Clone()是浅拷贝，Copy()是深拷贝。

---


***转载请注明出处***